// new module script
#define NLETTERS 8

Character * ar_letter[NLETTERS];

void shouldLetterBeTrashed(Character * cALetter){
  if(cALetter.Room == player.Room && (cALetter.x < 0 || cALetter.x > GAMEW || cALetter.y < 0 || cALetter.y > GAMEH)){
    cALetter.ChangeRoom(TRASH);
  }
}

void game_start(){
  ar_letter[0] = cLetter1;
  ar_letter[1] = cLetter2;
  ar_letter[2] = cLetter3;
  ar_letter[3] = cLetter4;
  ar_letter[4] = cLetter5;
  ar_letter[5] = cLetter6;
  ar_letter[6] = cLetter7;
  ar_letter[7] = cLetter8;
}

void ThrowLetter(int x,  int y, CharacterDirection direction){
  Character * LetterChar;
  
  int i=0;
  while(i<NLETTERS){
    if(ar_letter[i].Room == TRASH){
      if(direction == eDirectionRight){
        ar_letter[i].ChangeRoom(player.Room, x+8, y);
      } else {        
        ar_letter[i].ChangeRoom(player.Room, x-8, y);
      }
      LetterChar = ar_letter[i];
      break;
    }
    i++;
  }
    
  LetterChar.Animate(0, 2, eRepeat, eNoBlock, eForwards);
  if(direction == eDirectionLeft){
    LetterChar.TweenX(1.2, x-GAMEW, eEaseLinearTween, eNoBlockTween);
    LetterChar.TweenY(0.3, y-40, eEaseOutExpoTween, eNoBlockTween);
    LetterChar.TweenY(0.7, y+40, eEaseLinearTween, eNoBlockTween, 0.3);
  } else {
  // must be right
    LetterChar.TweenX(1.2, x+GAMEW, eEaseLinearTween, eNoBlockTween);
    LetterChar.TweenY(0.3, y-40, eEaseOutExpoTween, eNoBlockTween);
    LetterChar.TweenY(0.7, y+40, eEaseLinearTween, eNoBlockTween, 0.3);
  }
  
}



void repeatedly_execute_always(){
  int i=0;
  while(i<NLETTERS){
    shouldLetterBeTrashed(ar_letter[i]);    
    i++;
  }

}